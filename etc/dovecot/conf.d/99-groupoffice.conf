#Enable IMAP
protocols = imap lmtp sieve

default_vsz_limit = 1G

#Set defaults, home and path are overriden by sql userdb
mail_driver = maildir
mail_home = /var/mail/vhosts/%{user|domain}/%{user|username}
mail_path = ~/Maildir
mail_inbox_path = ~/Maildir/.INBOX

#Enable the line below to enable external access for IMAP
#listen = *

# Group to enable temporarily for privileged operations. Currently this is
# used only for creating mbox dotlock files when creation fails for INBOX.
# Typically this is set to "mail" to give access to /var/mail.
#mail_privileged_group =
mail_privileged_group = mail

# Grant access to these supplementary groups for mail processes. Typically
# these are used to set up access to shared mailboxes. Note that it may be
# dangerous to set these if users can create symlinks (e.g. if "mail" group is
# set here, ln -s /var/mail ~/mail/var could allow a user to delete others'
# mailboxes, or ln -s /secret/shared/box ~/mail/mybox would allow reading it).
mail_access_groups = mail

# Valid UID range for users, defaults to 500 and above. This is mostly
# to make sure that users can't log in as daemons or other system users.
# Note that denying root logins is hardcoded to dovecot binary and can't
# be done even if first_valid_uid is set to 0.
first_valid_uid = 150
last_valid_uid = 150
first_valid_gid = 8
last_valid_gid = 8


mail_plugins {
  acl = yes
  quota = yes
  quota_clone = yes
  fts = yes
  fts_xapian = yes
  virtual = yes
}

postmaster_address = postmaster@localhost.localdomain

auth_mechanisms = plain login

#FOR DEVELOPMENT ONLY:
auth_allow_cleartext = yes

# For users that can login to all mailboxes of a domain
auth_master_user_separator = *

sql_driver = mysql
#mysql {dbHost} {
#  user = {dbUser}
#  password = {dbPass}
#  dbname = {dbName}
#}

#auth_debug=yes
#auth_debug_passwords=yes
log_debug = (category=mail OR category=imap OR category = auth)

mysql db {
  user = groupoffice
  password = groupoffice
  dbname = groupoffice
}

passdb groupoffice_domain_owner {
    driver = sql
    default_password_scheme = CRYPT
    passdb_sql_query = SELECT \
        username AS user, \
        password \
        FROM community_maildomains_mailbox \
        WHERE username = '%{user}' AND active = '1' AND domainOwner = true AND '%{login_user | domain }'='%{auth_user | domain}'

    master = yes
    result_success = continue
}


passdb sql {
  default_password_scheme = CRYPT
  driver = sql
  query = SELECT \
      username AS user, \
      password, \
      CONCAT('/var/mail/vhosts/', homedir) AS userdb_mail_home, \
      CONCAT('/var/mail/vhosts/', maildir) AS userdb_mail_path, \
      150 AS userdb_uid, 8 AS userdb_gid, \
      CONCAT(quota, 'B') AS userdb_quota_storage_size, \
      IF(fts, "xapian", null) as 'userdb_fts/xapian/fts_driver', \
      IF(fts, "+XFTS", null) as userdb_imap_capability, \
      'Trash Spam' as 'userdb_namespace/inbox/mailbox', \
      autoExpunge as 'userdb_namespace/inbox/mailbox/Trash/autoexpunge', \
      autoExpunge as 'userdb_namespace/inbox/mailbox/Spam/autoexpunge' \
      FROM community_maildomains_mailbox \
      WHERE username = '%{user}' AND active = '1' AND ('%{protocol | lower}' != 'smtp' OR smtpAllowed=1)
}

# "prefetch" user database means that the passdb already provided the
# needed information and there's no need to do a separate userdb lookup.
# <doc/wiki/UserDatabase.Prefetch.txt>
userdb prefetch {
    userdb_driver = prefetch
}

# The userdb below is used only by lda.
userdb sql {
    driver = sql
    query = SELECT \
          CONCAT('/var/mail/vhosts/', homedir) AS mail_home, \
          CONCAT('/var/mail/vhosts/', maildir) AS mail_path, \
          150 AS uid, 8 AS gid, \
          CONCAT(quota, 'B') AS quota_storage_size, \
          IF(fts, 'xapian', null) as 'fts/xapian/fts_driver', \
          IF(fts, '+XFTS', null) as imap_capability, \
          'Trash Spam' as 'namespace/inbox/mailbox', \
          autoExpunge as 'namespace/inbox/mailbox/Trash/autoexpunge', \
          autoExpunge as 'namespace/inbox/mailbox/Spam/autoexpunge' \
          FROM community_maildomains_mailbox \
          WHERE username = '%{user}' AND active = '1'

    # For using doveadm -A:
    iterate_query = SELECT username AS user FROM community_maildomains_mailbox
}


# Default to no fsyncing, lmtp and lda use optimized
mail_fsync = never

# Should saving a mail to a nonexistent mailbox automatically create it?
lda_mailbox_autocreate = yes

# Should automatically created mailboxes be also automatically subscribed?
# This is useful when there are sieve rules pointing to non existent folders
# when they have been moved. The folder will reappear instead of staying invisble to the user
lda_mailbox_autosubscribe = yes

protocol lda {
  mail_plugins {
      quota = yes
      sieve = yes
  }
  mail_fsync = optimized
}

protocol imap {
  mail_plugins {
    imap_acl = yes
    imap_quota = yes
  }
}

protocol lmtp {
  # The debian default is %{user | username} so we need to reset that for our db lookup.
  auth_username_format = %{user|lower}
  mail_plugins {
    quota = yes
    sieve = yes
 }
  mail_fsync = optimized
}

namespace inbox {
  type = private
  separator = /
  prefix =
  #location defaults to mail_location.
  inbox = yes

  # These mailboxes are widely used and could perhaps be created automatically:
  mailbox Drafts {
    auto = subscribe
    special_use = \Drafts
  }
  mailbox Junk {
    special_use = \Junk
  }

  mailbox Spam {
    auto = subscribe
    special_use = \Junk
    fts_autoindex = no

    # Enable autoexpunge below to cleanup the Spam folder automatically
    # autoexpunge = 30d
  }

  mailbox Trash {
    auto = subscribe
    special_use = \Trash
    fts_autoindex = no
    # Enable autoexpunge below to cleanup the Trash folder automatically
    # autoexpunge = 30d

    # 110% * 10000 = 11000 limit
    quota_message_percentage = 110
    # 110% * 1G = 1100M
    quota_storage_percentage = 110
  }

  # For \Sent mailboxes there are two widely used names. We'll mark both of
  # them as \Sent. User typically deletes one of them if duplicates are created.
  mailbox Sent {
    auto = subscribe
    special_use = \Sent
  }
  mailbox "Sent Messages" {
    special_use = \Sent
  }

  # If you have a virtual "All messages" mailbox:
  mailbox virtual/All {
    special_use = \All
  }
}

namespace shared {
	type = shared
	separator = /
	prefix = shared/$user/

	mail_driver = maildir
    mail_path = %{owner_home}/Maildir
	mail_index_private_path = ~/Maildir/shared/%{owner_user}

	subscriptions = no
	list = children
}


namespace virtual {
	prefix = virtual/
    separator = /
    hidden = yes
    list = no
    subscriptions = no

    mail_driver = virtual
    mail_path = /etc/dovecot/virtual
    mail_index_path = /var/mail/vhosts/%{user | domain }/%{user | username }/virtual
}

service imap-login {
  inet_listener imap {
    #port = 143
  }
  inet_listener imaps {
    #port = 993
    #ssl = yes
  }


  # Number of processes to always keep waiting for more connections.
  process_min_avail = 4

  # If you set service_count=0, you probably need to grow this.
  vsz_limit = 1G
}

service lmtp {
 unix_listener /var/spool/postfix/private/dovecot-lmtp {
   group = postfix
   mode = 0600
   user = postfix
  }
}

service auth {
  # auth_socket_path points to this userdb socket by default. It's typically
  # used by dovecot-lda, doveadm, possibly imap process, etc. Its default
  # permissions make it readable only by root, but you may need to relax these
  # permissions. Users that have access to this socket are able to get a list
  # of all usernames and get results of everyone's userdb lookups.
  unix_listener auth-userdb {
    mode = 0600
    user = vmail
    group = mail
  }

  # Postfix smtp-auth
  unix_listener /var/spool/postfix/private/auth {
    mode = 0666
  }
}

dict_server {
  dict mysql {
    driver = sql
    sql_driver = mysql

    dict_map priv/quota/messages {
      sql_table = community_maildomains_mailbox
      username_field = username
      value_field messages {
      }
    }

    dict_map priv/quota/storage {
      sql_table = community_maildomains_mailbox
      username_field = username
      value_field bytes {
      }
    }
  }
}

quota_clone {
  dict proxy {
    name = mysql
  }
}

service dict {
  unix_listener dict {
    mode = 0660
    user = vmail
    group = mail
  }
}


quota user {
  warning warn-95 {
    quota_storage_percentage = 95
    execute quota-warning {
      args = 95 %{user}
    }
  }
  warning warn-80 {
    quota_storage_percentage = 80
    execute quota-warning {
      args = 80 %{user}
    }
  }
  warning warn-under {
    quota_storage_percentage = 100
    # user is no longer over quota
    threshold = under
    execute quota-warning {
      args = below %{user}
    }
  }
}

service quota-warning {
  executable = script /usr/bin/quota-warning.sh
  # use some unprivileged user for executing the quota warnings
  user = vmail
  unix_listener quota-warning {
  }
}

sieve_script default {
  type = default
  name = default
  driver = file
  path = /var/mail/vhosts/default.sieve
}

acl_driver = vfile
# Dict for mapping which users have shared mailboxes to each other.
acl_sharing_map {
  dict file {
    path = /var/lib/dovecot/db/shared-mailboxes.db
  }
}

# ACL username
# defaults to master_user, but if it expands to empty, will use current user.
#acl_username = %{master_user}

# fts is returned from the userdb and passdb sql database so it can be turned on per user
fts xapian {
    fts_driver =
    verbose = 0
    partial = 3
}

language "en" {
        default = yes
}

# Proactively index mail as it is delivered or appended, not only when
# searching.
fts_autoindex = yes

# How many \Recent flagged mails a mailbox is allowed to have, before it
# is not autoindexed.
# This setting can be used to exclude mailboxes that are seldom accessed
# from automatic indexing.
fts_autoindex_max_recent_msgs=99

# Avoid spending excessive time waiting for the quota calculation to finish
# when mails' vsizes aren't already cached. If this many mails are opened,
# finish the quota calculation on background in indexer-worker process. Mail
# deliveries will be assumed to succeed, and explicit quota lookups will
# return internal error. (v2.2.28+)
protocol !indexer-worker {
  mail_vsize_bg_after_count = 100
}

service indexer-worker {
  #Increase vsz_limit to 2GB or above.
  #Or 0 if you have rather large memory usable on your server, which is preferred for performance)
  vsz_limit = 2G
  process_limit = 30
}

# For better performance: https://doc.dovecot.org/configuration_manual/mail_location/Maildir/#core_setting-maildir_very_dirty_syncs
maildir_very_dirty_syncs = yes

# Mailbox list indexes can be used to optimize IMAP STATUS commands. They are
# also required for IMAP NOTIFY extension to be enabled.
# Recommended to use with the "autoexpunge" setting.
mailbox_list_index = yes

# Trust mailbox list index to be up-to-date. This reduces disk I/O at the cost
# of potentially returning out-of-date results after e.g. server crashes.
# The results will be automatically fixed once the folders are opened.
mailbox_list_index_very_dirty_syncs = yes

# Recommended when using the "autoexpunge" setting with sdbox or Maildir, as it avoids using stat() to find out the mail’s
# saved-timestamp. With mdbox and obox formats this isn’t necessary, since the saved-timestamp is always available.
mail_always_cache_fields = date.save

# Also for performance cache auth
auth_cache_size = 10MB
auth_cache_ttl = 1 hour
auth_cache_negative_ttl = 1 hour